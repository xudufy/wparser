#include "../wparser.h"
#include <map>

void printUsage() {
    printf("usage: wasm-pc2func <wasm file> [-s <query_location_hex>] [-S <symbol_file>] [-n]\n"
    "-s <query_location_hex> will output a function id for the location hex\n"
    "-n                      will try to output the name of the function at the place where function id will show.\n"
    "-S <symbol_file>        can give a symbol file generated by emcc to map the function name\n");
}


bool readSymbolFile(std::string path, std::map<uint32_t, std::string> & outMap) {
    auto fp = fopen(path.c_str(), "r");
    char str[2000];

    if(fp == NULL) {
        W_LOG("Error opening file");
        return false;
    }
    if( fgets (str, 2000, fp)!=NULL ) {
        std::string line = str;
        auto colonpos = line.find(':');
        uint32_t fid = std::stoul(line.substr(0, colonpos), nullptr, 0);
        std::string name = line.substr(colonpos + 1);
        outMap[fid] = std::move(name);
    }
    fclose(fp);
    return true;
}

/**
 * support:
 * 1. output function pc mapping.
 * 1.1. TODO: cache pc mapping. 
 * 2. search function id by pc.
 * 3. search function name by pc if namesec provided.
 * 3. search function name by pc if symbol file provided.
*/
int main(int argc, char*argv[]) {
    using namespace wparser;
    std::string symbol_file_path;
    std::string wasm_file_path;
    bool name_mode = false;
    bool query_mode = false;
    uint32_t query_location = 0;
    wasm_file_path = argv[1];
    int argCursor = 2;
    std::map<uint32_t, std::pair<size_t, size_t>> funcExtentMap;
    std::map<uint32_t, std::string> funcNameMap;
    std::shared_ptr<wasm::module_t> mod;
    if (argc < 2) {
        goto err;
    }

    while(argCursor < argc) {
        std::string arg = argv[argCursor];
        if (arg == "-s") {
            query_mode = true;
            if (argCursor + 1 == argc) {
                goto err;
            } else {
                std::string ll = argv[++argCursor];
                query_location = std::stoul(ll, nullptr, 0);
            }
        } else if (arg == "-n") {
            name_mode = true;
        } else if (arg == "-S") {
            if (argCursor + 1 == argc) {
                goto err;
            } else {
                symbol_file_path = argv[++argCursor];
            }
        }
        argCursor++;
    }

    mod = wparser::parse(argv[1]);
    W_LOG("module size: %zu", mod->extent.end);
    for (auto & item: mod->codesec) {
        for (auto & func: item->func) {
            funcExtentMap[func->funcidx] = std::make_pair(func->extent.start, func->extent.end);
            if (func->debuginfo_name != "") {
                funcNameMap[func->funcidx] = func->debuginfo_name;
            }
        }
    }

    if (symbol_file_path.size() > 0) {
        readSymbolFile(symbol_file_path, funcNameMap);
    }

    if (!query_mode) {
        if (!name_mode) {
            for (auto iter: funcExtentMap) {    
                printf("%u: 0x%zx 0x%zx %zu\n", iter.first, iter.second.first, iter.second.second, iter.second.second - iter.second.first);
            }
        } else {
            for (auto iter: funcExtentMap) {
                std::string name;
                if (funcNameMap.count(iter.first) == 0) {
                    name = std::to_string(iter.first);
                } else {
                    name = funcNameMap[iter.first];
                }
                printf("%s: 0x%zx 0x%zx %zu\n", name.c_str(), iter.second.first, iter.second.second, iter.second.second - iter.second.first);
            }
        }
        return 0;
    }

    if (query_mode) {
        for (auto iter: funcExtentMap) {    
            if (query_location >= iter.second.first && query_location <= iter.second.second) {
                if (name_mode) {
                    std::string name;
                    if (funcNameMap.count(iter.first) == 0) {
                        name = std::to_string(iter.first);
                    } else {
                        name = funcNameMap[iter.first];
                    }
                    printf("%s\n", name.c_str());
                } else {
                    printf("%u\n", iter.first);
                }
                return 0;
            }
        }
        printf("<not_found>");
    }

    return 0;
err:
    printUsage();
    return 0;
}